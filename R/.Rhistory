alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
##pwrss package
optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.30, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
pwrss.t.reg(beta1 = 0.30, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = 0.02655371,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = 0.02655371,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = 0.02655371,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
##pwrss package
res <-moptimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
res$errorate
## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res <- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'two.sided')$power", error = "balance")
res$alpha
res$beta
res$errorate
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.10, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.05, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.05, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res <- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'one.sided')$power", error = "balance")
res$alpha
res$beta
## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res <- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'greater')$power", error = "balance")
res$alpha
res$beta
library(pwr)
library(pwrss)
1-pwr.t.test(d = 0.5, n = 100, sig.level = res$alpha, type = 'two.sample', alternative = 'greater')$power
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = FALSE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = TRUE)
res$alpha
res$beta
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = TRUE)
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
res$alpha
res$beta
1-pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)$power
res$alpha
res$beta
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.0001, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = TRUE)
res$alpha
res$beta
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = FALSE,
printplot = TRUE)
res$alpha
res$beta
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "balance",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res <- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'greater')$power", error = "minimize",
verbose = T,
printplot = T)
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
warnings()
fit <- pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = res$alpha,
alternative = 'superior',
verbose = TRUE)
fit$power
for(i in seq(0, 0.2, 0.01)){
fit <- pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = i,
alternative = 'superior',
verbose = TRUE)
print(fit$power)
}
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.2, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
fit <- pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = .38,
alternative = 'superior',
verbose = TRUE)
print(fit$power)
fit <- pwrss::pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400, alpha = .38,
alternative = 'superior',
verbose = TRUE)
fit$power
fit$parms
fit$test
fit$power
print(fit$power)
fit
##pwrss package
res <-optimal_alpha(power_function = "pwrss::pwrss.t.reg(beta1 = 0.1, beta0 = 0, margin = 0.05,
k = 3, r2 = 0.30, n=400,
alternative = 'superior',
verbose = FALSE)$power",
error = "minimize",
costT1T2 = 1,
priorH1H0 = 1,
verbose = TRUE,
printplot = TRUE)
res$alpha
res$beta
library(pwr)
library(pwrss)
1-pwr.t.test(d = 0.5, n = 100, sig.level = res$alpha, type = 'two.sample', alternative = 'greater')$power
## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res <- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'greater')$power", error = "minimize",
verbose = T,
printplot = T)
?optimal_alpha
getwd()
library(rstan)
rstan_options(auto_write = TRUE)
library(foreach)
library(doParallel)
util <- new.env()
source('stan_utility.R', local=util)
1^1/2
reduction <- function(k){
1/2^k
}
reduction(1:100)
reduction <- function(k){
1/2^k/10)
1
reduction(c(5, 10, 15, 20))
reduction <- function(k){
1/2^(k/10)
}
reduction(c(5, 10, 15, 20))
qnorm(3.39)
pnorm(3.39)
install.packages("multicon")
data(lensData)
DIAMONDS.in <- lensData[,32:39] # Self-ratings on 8 Situation Characteristics
library(MetaUtility)
z_to_r(1)
z_to_r(1)
r_to_d
r_to_d(z_to_r(0.7))
z_to_r(0.7)
r_to_d(0.7)
?r_to_d
library(RoBMA)
?d_to_logRR
library(RoBMA)
d2r(1)
d2z(1)
install.packages("installr")
installr::updateR()
library(devtools)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(metamix)
library(RoBMA)
data("mertens_nudge")
hist(mertens_nudge$cohens_d, breaks = 100)
mertens_nudge <- subset(mertens_nudge, cohens_d < 1.5)
mertens_nudge <- mertens_nudge[!grepl("^Wansink", mertens_nudge$reference), ]
hist(mertens_nudge$cohens_d, breaks = 100)
#fit models with one-sided selection
fit1_metamix_pb <- sel_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d), M = 1, steps = c(0.5, 0.975), chains = 4, cores = 4)
fit2_metamix_pb <- sel_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d), M = 2, steps = c(0.5, 0.975), chains = 4, cores = 4)
fit3_metamix_pb <- sel_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d), M = 3, steps = c(0.5, 0.975), chains = 4, cores = 4, iter = 30000, warmup = 10000)
library(bridgesampling)
ml1_pb = bridge_sampler(fit1_metamix_pb)
ml2_pb = bridge_sampler(fit2_metamix_pb)
ml3_pb = bridge_sampler(fit3_metamix_pb)
# Save all
save(fit1_metamix_pb, fit2_metamix_pb, fit3_metamix_pb,
ml1_pb, ml2_pb, ml3_pb,
file = "metamix_pb_onesided.RData")
# Fit models
fit1_metamix <- re_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d),
M = 1, chains = 4, cores = 4)
fit2_metamix <- re_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d),
M = 2, chains = 4, cores = 4)
fit3_metamix <- re_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d),
M = 3, chains = 4, cores = 4)
# Compute marginal likelihoods
ml1_nobias <- bridge_sampler(fit1_metamix)
ml2_nobias <- bridge_sampler(fit2_metamix)
ml3_nobias <- bridge_sampler(fit3_metamix)
# Save all
save(fit1_metamix, fit2_metamix, fit3_metamix,
ml1_nobias, ml2_nobias, ml3_nobias,
file = "metamix_nobias.RData")
load("metamix_nobias.RData")
load("metamix_pb_onesided.RData")
# Combine all log marginal likelihoods into a named vector
logml_all <- c(
pb_M1      = ml1_pb$logml,
pb_M2      = ml2_pb$logml,
pb_M3      = ml3_pb$logml,
nobias_M1  = ml1_nobias$logml,
nobias_M2  = ml2_nobias$logml,
nobias_M3  = ml3_nobias$logml
)
# Stabilize using log-sum-exp trick
logml_centered <- logml_all - max(logml_all)
unnormalized <- exp(logml_centered)
posterior_probs <- unnormalized / sum(unnormalized)
# Output posterior probabilities
posterior_probs
fit4_metamix_pb <- sel_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d), M = 4, steps = c(0.5, 0.975), chains = 4, cores = 4, iter = 30000, warmup = 10000)
fit4_metamix <- re_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d),
M = 4, chains = 4, cores = 4, iter = 30000, warmup = 10000)
ml4_pb <- bridge_sampler(fit4_metamix_pb)
ml4_nobias <- bridge_sampler(fit4_metamix)
save(fit4_metamix, fit4_metamix_pb, ml4_pb, ml4_nobias,
file = "4mix.RData")
load("4mix.RData")
# Combine all log marginal likelihoods into a named vector
logml_all <- c(
pb_M1      = ml1_pb$logml,
pb_M2      = ml2_pb$logml,
pb_M3      = ml3_pb$logml,
pb_M4      = ml4_pb$logml,
nobias_M1  = ml1_nobias$logml,
nobias_M2  = ml2_nobias$logml,
nobias_M3  = ml3_nobias$logml,
nobias_M4  = ml4_nobias$logml
)
# Stabilize using log-sum-exp trick
logml_centered <- logml_all - max(logml_all)
unnormalized <- exp(logml_centered)
posterior_probs <- unnormalized / sum(unnormalized)
# Output posterior probabilities
posterior_probs
rstan::summary(fit3_metamix_pb, pars = c("mu", "tau", "omega", "theta"))$summary[ , c("mean", "2.5%", "97.5%")]
rstan::summary(fit4_metamix_pb, pars = c("mu", "tau", "omega"))$summary[ , c("mean", "2.5%", "97.5%")]
max_rhat_fit3 <- max(rstan::summary(fit3_metamix_pb)$summary[, "Rhat"], na.rm = TRUE)
max_rhat_fit3
summary_fit4 <- rstan::summary(fit4_metamix_pb, pars = c("mu", "tau", "omega"))$summary
max_rhat_fit4 <- max(summary_fit4[, "Rhat"], na.rm = TRUE)
max_rhat_fit4
fit5_metamix_pb <- sel_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d), M = 5, steps = c(0.5, 0.975), chains = 4, cores = 4, iter = 30000, warmup = 10000)
fit5_metamix <- re_mix(y = mertens_nudge$cohens_d, sd = sqrt(mertens_nudge$variance_d),
M = 5, chains = 4, cores = 4, iter = 30000, warmup = 10000)
ml5_pb <- bridgesampling::bridge_sampler(fit5_metamix_pb)
ml5_nobias <-  bridgesampling::bridge_sampler(fit5_metamix)
save(fit5_metamix, fit5_metamix_pb, ml5_pb, ml5_nobias,
file = "5mix.RData")
summary_fit5 <- rstan::summary(fit5_metamix_pb, pars = c("mu", "tau", "omega"))$summary
max_rhat_fit5 <- max(summary_fit4[, "Rhat"], na.rm = TRUE)
max_rhat_fit5
load("5mix.RData")
# Combine all log marginal likelihoods into a named vector
logml_all <- c(
pb_M1      = ml1_pb$logml,
pb_M2      = ml2_pb$logml,
pb_M3      = ml3_pb$logml,
pb_M4      = ml4_pb$logml,
pb_M5      = ml5_pb$logml,
nobias_M1  = ml1_nobias$logml,
nobias_M2  = ml2_nobias$logml,
nobias_M3  = ml3_nobias$logml,
nobias_M4  = ml4_nobias$logml,
nobias_M5  = ml5_nobias$logml
)
# Stabilize using log-sum-exp trick
logml_centered <- logml_all - max(logml_all)
unnormalized <- exp(logml_centered)
posterior_probs <- unnormalized / sum(unnormalized)
# Output posterior probabilities
posterior_probs
setwd("C:/github")
install.packages("metamix_0.0.0.9000.tar.gz", repos = NULL, type="source")
setwd("C:/github/metamix/R")
devtools::build(binary = TRUE)
